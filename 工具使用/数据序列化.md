## 数据序列化

*序列化和反序列化主要就是解决在跨平台跨语言的情况下，模块（程序）之间的交互与调用，最本质问题就是解决数据的传输问题。*           



### 序列化

如何把我们程序里面活的对象的状态信息保存下来，保存下来后我们又如何对其进行反序列化（得到程序可使用的对象）。          



#### 网络通信中的问题分析

通过网络发送数据属于：内存数据---->（另一个主机）内存数据           

但是有一些问题：        

* 平台不同：类型所占用的大小可能不同32bit  64bit
* 大小端的问题（字符串数据不需要担心）在网络编程里面我们也仅仅在端口与ip使用了
* 语言不同：各个语言的类型占用的空间
* 字节对齐问题：





## protobuf

除了些许学习成本外，几乎没有缺点。



通过源码编译安装的以后的升级肯定还是得通过源码。

不同的实体/程序之间交流肯定得有一个都能听得懂的语言啊，在protobuf下这个语言就是`.proto`文件。

反正从主机接收的都是字符串数据，只要按照proto里面定义的来解析即可。



**Q1：prorobuf里面定义数据时候的=1是干什么**   

> 在 Protocol Buffers（protobuf）中，等号后面的数字表示该字段的标识符或者字段号。这个数字是用来标识一个字段的，在序列化和反序列化过程中使用。*每一个字段都必须有一个唯一的标识符。*
>
> 在定义消息的时候，每个字段都需要指定一个唯一的标识符，标识符必须是正整数，并且必须在消息中唯一。*这个标识符是用来识别消息中的每个字段，它们在二进制数据中被编码成键值对的形式，标识符就是键，字段的值就是值。* (protobuf是比json紧凑的存储，但是也得保存一些来获取是哪个字段)
>
> **在字段的定义中，等号后面的数字表示该字段的标识符或者字段号。它可以是任何正整数，但是必须是唯一的，因为在序列化和反序列化过程中会使用这个标识符来识别每个字段。例如，下面的示例中，"id" 字段的标识符为 1：**
>
> ```protobuf
> message Person{
>  int32 id=1;
>  string name=2;
>  string email=3;
> }
> //这里面的1，2，3就相当于使用json时候的key，只不过protobuf更节约
> ```
>
> 当使用 Protocol Buffers 编码消息时，每个字段都将被编码成一个键值对，键是该字段的标识符，值是该字段的值。因此，在解码消息时，程序将使用标识符来确定消息中的每个字段。
>
> （从这也知道了，protobuf接收到一块二进制数据是如何解析到不同的字段的==》肯定是存储了冗余信息）

**Q: prorobuf收到一块数据是如何知道改怎么序列化的**   

> 在使用 Protocol Buffers（protobuf）进行序列化和反序列化时，需要使用消息的定义来确定如何编码和解码数据。
>
> 当你发送一个 protobuf 消息时，它会被编码成一个二进制数据块。这个二进制数据块包含了消息中每个字段的类型、标识符和值等信息。在接收方收到这个二进制数据块后，需要使用与发送方相同的消息定义来解码数据。通过解码数据时消息定义中的标识符，接收方可以确定每个字段的类型和值，然后使用这些信息来构造一个与发送方相同的 protobuf 消息。
>
> 因此，接收方必须事先知道消息的定义才能正确地解码数据。一般来说，消息的定义通常通过共享同一个 .proto 文件来实现。在这种情况下，发送方和接收方都可以使用相同的 .proto 文件来定义消息结构，以确保它们可以正确地序列化和反序列化数据。
>
> 除了共享 .proto 文件，Protocol Buffers 还支持通过其它方式来共享消息定义，例如使用 Protocol Buffers 的反射机制或者使用动态消息库来动态生成消息类。无论使用哪种方式，接收方必须在解码数据之前了解消息的定义，以便正确地解码数据。







## json

json是文本存储的json字符串，序列化为json字符串，从字符串反序列化为json结构。

```C++
#include "json.hpp" #采用的nlohman的head onlyjson

using json=nlohmann::json;

string msgStr;
json js=json::parse(msgStr);
js["msgid"].get<int>(); //从json字符串获取int
int id=js["id"]; //
string pwd=js["pwd"]; //

json resp;
resp["msgid"]=LOGIN_MSG_ACK;
resp["msg"]="hello,wrold";

//这个json库还是很强大的可以直接存放容器
//还是不太熟悉，用到了再说吧
```

