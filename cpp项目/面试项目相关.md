记录一下项目中的问题，面试角度，面试出现的问题。       

抄项目也可以，但是一定要懂，面试官自己不一定看过。你要给他讲懂，体现自己的任务量+思考。     

自圆其说即可，关键要讲出来。     项目准备好了就是八股文+算法。           

别怕了，面对问题，解决问题。 本来时间都不够



## 自我介绍

这个千万别应付，给面试官看你简历的时间。1--3min      

应该根据具体的公司而定！说一些相关的不要全部用一套。     

​       



手机上面有。



## 集群服务器

**项目介绍：**    

这个项目是一个网络聊天服务器项目，它分为了四个模块。

首先，第一个介绍网络模块，网络模块这方面我采用的是开源的muduo网络库来进行设计的；这个模块的主要作用就是解耦网络模块与业务模块的代码，使得后面的开发过程中专注业务的开发。（如何解耦？网络模块仅仅负责连接的 建立/断开，客户消息到达时候进行读取数据。我做的就是从客户消息json格式，提取出该消息类型）         

另外就是业务模块，我采用了一些C++11的技术比如：哈希表（存放的是msgid与对应的处理函数），function和bind绑定器实现的回调机制。主要就是实现了这么一个功能，根据用户发送的json消息，解析出消息id（自定义的信息格式）对应的服务，并通过回调相应的业务代码进行处理。

然后就是数据存储层模块，我使用的是MySQL数据库进行关键数据的落盘，这一块的代码主要采用类似于ORM的方法避免业务层直接书写sql代码，解耦了业务层与数据层的代码。    

*单机服务下主要就是这几个模块，但是单机的性能有限。*（fd限制等等）

我就通过配置nginx实现了基于tcp（长连接）的负载均衡，将服务器进行水平拓展实现了服务器的集群。  

在集群环境下不同的用户可能登录到不同的服务器，这样为了实现不同服务器上用户之间通信的问题（主要就是解决服务器之间的通信因为我们时cs结构服务器推送消息）采用了基于redis的发布订阅机制，实现了跨服务器的通信。      

### 项目问题

这个结合那个md看看。        

* 负载均衡再看看，不能就会个轮询，

  nginx的基于http的负载均衡；这里我们使用的是基于tcp的，因为我们采用的是私有协议进行通信。

* redis的相关：不能就会个发布订阅，还知道哪些服务器中间件（MQ）？

  redis主要是作为缓冲服务器（会用吗？）     分布式锁，发布订阅

  在那些专业的MQ里面redis的发布-订阅功能里的channel（频道）叫做topic。



**面试问，项目遇到的问题？**     

1、第一次写业务层代码的时候直接把sql语句写到了业务层代码里里面，但是sql语句越写越多，代码越来越长。就想着能不能使用一种方法减少工作量。就在网上查发现可以使用ORM的方式。但是在网上看了很多例子很少有C++的orm框架，就进行了自己的实现。自己的实现也很简单就是数据库的每个表对于一个成员类，再写一个用于向数据库操作成员的方法类，这样业务层就不需要出现sql代码，而是使用方法类来操控对象。



2、一次使用muduo的log时候，发现无法输出C++11自带的thread::id

然后就去看了muduo日志实现的源码，发现网络库的实现并不是采用的iostream，而是自定义的logStream。我又看了标准库的thread：：id发现这不是一个成员变量而是一个类，这个类仅对标准库的operator<<进行重载。这时就有两条方法去修改bug：1、修改网络库的源码  2、使用手段访问private变量，查看了id类的内存布局

```C++
//访问私有成员变量的方法，适用于简单的（已经知道对象内存布局）
class Foo{
    int a=10;
    char c='c';
    short s=0x00000010;//num 2
};

Foo foo;
int* pfooint=(int*)(char*)&foo;
char* pfoochar=(char*)(pfooint+1);
short* pfooshort=(short*)(pfoochar+2);//知道内存布局即可一一获取
```





3、**一个运行时调试的bug：（把这个好好写一下还可以）**     

在实现基于redis的发布订阅功能时候，在测试的时候发现这个模块总是在发布消息之后，订阅方接受消息时候coredump了。但是这个运行我查看日志发现各个部分都没有问题，这时也没多想直接手动恢复数据库模拟测试环境，试了好多次发现还是那个问题。然后开始改代码发现是因为一个redis连接代码有问题，这个代码是连接成功返回true，但是忘了写返回值导致这个行为未定义。      

之后我就想为什么找bug这么慢我总结了两条：

1、日志不够详细，只打印了连接失败日志，而没有打印连接成功日志。 关键步骤打日志 

2、没有开启编译器的警告，导致一些编译期就能发现的问题，直到运行时才解决。





## webserver

### reactor模型



reactor模型到底是什么，如何给面试官讲解？      如何实现一个现代C++的reactor？     

reactor是一个常见的网络事件处理模型。

一个epoll是一个reactor，单reactor。我们的项目使用的是多个reactor==》main reactor&sub reacor结合。同时把sub reactor当作IO线程池。

* * 

  

### one loop per thread

这个方式的好处P62。 ==》详细读一下 

这是一个网络服务器项目，最早的时候是我看完《Linux高性能服务器编程》自己写了一个单reactor+计算线程池的（单事件循环+线程池）服务器。但是这种写法有很大问题，比如需要解决同一个connectedfd被不同的线程处理的问题。后来看了陈硕的《Linux多线程服务端编程》了解了一种叫做one loop per thread的并发方案，也就是每个线程都是一个事件循环，只负责注册到自己线程的事件。就解决了那种问题。        

第一次使用的是线程池，并发模型是thread per connection



同时因为计算任务很少，就没有使用线程池。

采用了one 这种模式就需要实现线程安全的reactor！如何保证线程安全？第八章       允许一个线程（main reactor/main loop）往别的线程loop的塞东西！





为什么使用eventfd而不是pipe唤醒？pipe典型的使用场景：写reactor时候用来异步唤醒epoll_wait（从陈硕的书里可以看出reactor与event loop在语境上可以互换）Reactor模式就是non-blockingIO+IO复用==》事件循环



为什么使用LT而不是epoll独特的ET



看书的时候记下一些关键点，面试时候讲清楚。 比如tcpconnection生命周期的管理。



### buffer设计

为什么陈硕说使用了栈上空间是一个创新？有什么作用？确实挺不错，因为buffer是每个tcpconnection都得两个，直接开的很大的话会很消耗空间。



今天算是浪费一天，睡觉了

### timrfd&&eventfd

**为什么使用timerfd作为定时？**        

for timerfd： man timerfd_create

P242：timerfd入选的原因。避免使用信号作为定时任务；并且timerfd也是一个fd可以很好的和reactor融合起来用统一的方式处理定时事件&&IO事件，像处理IO事件一样处理超时事件。通过文件描述符来通知定时事件的到来



**为什么使用eventfd而不使用常用的pipe？**      

man eventfd 

>chatgpt来告诉你
>
>timefd和eventfd都是Linux下的文件描述符，用于实现异步I/O（通知）的机制。它们都是通过在内核中创建相应的文件描述符来实现异步通知（其实还是同步IO）的。下面是它们的优点及特点：
>
>1. timefd==>man timerfd_create
>
>timefd可以用来创建一个文件描述符，当定时器到期时会触发该文件描述符上的事件。timefd支持设置相对时间和绝对时间，并且可以支持多个定时器。timefd是一个高精度的定时器，可以达到纳秒级别的精度。timefd的主要优点包括：
>
>- 高精度：timefd可以提供纳秒级别的精度，比传统的定时器更加精确。
>
>- 高效性：使用timefd可以减少系统调用的数量，提高效率。
>
>- 可以设置多个定时器：timefd支持设置多个定时器，可以同时处理多个定时器事件。
>
>- linux下还有其他的定时方式eg：
>
> epoll返回超时，使用信号alarm。使用epoll定时效率不行，使用信号的话又会和多线程搅在一块。
>
>1. eventfd
>
>eventfd也是用来创建一个文件描述符，当该文件描述符上的事件触发时，可以通知应用程序。eventfd支持两种事件类型：读事件和写事件。读事件会在文件描述符上累积一个计数器，写事件会减少计数器的值。eventfd的主要优点包括：
>
>- 简单易用：eventfd的接口比较简单，使用方便。
>- 高效性：使用eventfd可以减少系统调用的数量，提高效率。
>- 支持异步事件通知：eventfd可以支持异步事件通知，避免了阻塞等待事件的情况。
>
>为什么使用eventfd而不使用pipe作为服务器唤醒的通知机制？
>
>虽然pipe也可以用来实现异步I/O通知机制，但是使用eventfd相比使用pipe有以下优点：
>
>- eventfd的接口比较简单易用，使用方便，而pipe的使用则比较复杂。
>- eventfd可以支持异步事件通知，而pipe只能支持同步事件通知，会造成线程阻塞的情况。
>- eventfd在事件触发时只需要写一个整数值到文件描述符上，而pipe需要写入实际的数据，多出的数据需要占用额外的空间和时间。
>- eventfd可以同时支持读写事件，而pipe只支持读写其中的一个方向。
>- **pipe常用的就是在进程间通信，这就需要内核提供专门的缓冲区，开销比较大。至少也得一个内存页。**
>- **pipe可能还会导致阻塞，比如写满了。因为pipe的容量是有限制的。**
>- eventfd就是内核维护的8字节整数计数器
>
>综上所述，使用eventfd比使用pipe更加适合作为服务器唤醒的通知机制。



### 简历输出

**项目介绍**      

这是一个网络服务器项目，最早的时候是我看完《Linux高性能服务器编程》自己写了一个单reactor+计算线程池的（单事件循环+线程池）服务器。但是这种写法有很大问题，比如需要解决同一个connectedfd被不同的线程处理的问题。

后来看了陈硕的《Linux多线程服务端编程》了解了一种叫做one loop per thread的并发方案，也就是每个线程都是一个事件循环，只负责注册到自己线程的事件。就解决了那种问题。



这玩意都没啥介绍的。      

a) 使用 Epoll 边沿触发的 IO 多路复用技术，非阻塞 IO，使用 Reactor 模式
b) 使用多线程，并使用线程池避免线程频繁创建销毁的开销
c) 基于小根堆的定时器关闭超时连接==》定时器精度？采用的timerfd？什么时候超时？
d) 使用 eventfd 实现了线程的异步唤醒==》为什么使用eventfd不是pipe？
e) 使用双缓冲技术实现了简单的异步日志系统==》如何实现？
f) 使用状态机解析了 HTTP 请求， 支持管线化请求==》管线化请求如何实现？
g) 支持优雅关闭连接  ==》什么是优雅？如果对方不优雅呢？

### 项目问题

**关键是简历里面有的一定需要会，关键是简历里写的一定要会**         

不是看你做了多少项目，而是面试时候能说多少。

* 为什么使用eventfd&&timerfd

  timerfd&&eventfd是Linux事件通知中很常用的，

* 为什么使用LT而不是epoll独特的ET

  LT一个显著的有点就是不会丢数据，处理一个用户也仅仅需要一次syscall。ET模式每次都得读到EAGAIN发生，并且只要一次没有处理就会导致后面的不处理，这就带来了一个问题，如果用户发来的数据很大，而且一直保持可读怎么办？但是LT下发消息挺麻烦的。

  当然最好的实现是发送消息采用ET，接受消息使用LT，但是内核不支持这样设置。

* reactor和proactor（反应堆&&前摄器）他们的区别？

  

* 为什么使用reactor？

  非阻塞IO要配合IO复用（epoll）来使用。如果不使用特定的模式一般使用IO复用都是使用面向过程的方法写的，这样的开发的效率不高，而且很难做到高并发。  我的理解就是Reactor模式对各个功能进行了划分，也就是采用了面向对象的方法。

  前面提到的 Reactor 是非阻塞同步网络模式，而 **Proactor 是异步网络模式**。Linux下异步IO很难使用，我就用了非阻塞同步IO的reactor

* timerfd的精度，定时的时间，定时器实现（这个有点虚，没看源码）

* 日志模块（这个也得看一下）如何实现的？



**遇到的问题，如何解决的？**      



1、理解reactor事件处理模型

我觉得这个项目的难点就是如何使用这些成熟的事件处理模型来实现高并发的IO。一开始看书的时候书上就说现在流行的一个网络库比如libevent/muduo/netty这些都是采用的reactor事件处理模型。当时就想着如何实现，可是在网上搜了好多博客，都讲得不是很好。直到最后我看了《Linux多线程服务端编程》，并看完了muduo的源码，这些问题自然而然就解决了。明白了reactor的四个关键组件如何实现的。



2、实现one loop per thread这种并发方案。

一个类似于线程单例的实现！使用thread local关键字。







## 一些问题

### 多线程和信号

>在Linux下，多线程和信号可能会发生冲突。这是因为多线程应用程序中的线程可以在任何时间点接收信号，而信号处理程序在中断当前进程的执行，以执行信号处理程序的代码。这可能会导致线程在临界区内被中断，从而导致数据损坏或竞争条件。
>
>为了避免这种冲突，可以使用以下方法之一：
>
>1. 在信号处理程序中使用线程安全的函数。例如，在信号处理程序中使用printf可能会导致竞争条件。相反，您可以使用线程安全的函数，例如pthread_mutex_lock和pthread_mutex_unlock来保护临界区，从而避免竞争条件。
>2. 屏蔽信号。可以使用sigprocmask函数屏蔽信号，从而防止在关键部分接收信号。请注意，在使用此方法时，您必须小心，以确保在处理完临界区后取消信号屏蔽。
>3. 将信号处理程序委托给专用线程。您可以为信号创建一个专用线程，并将信号处理程序委托给该线程，从而避免竞争条件。此方法需要您进行更多的编程工作，但可以提高代码的可读性和可维护性。
>
>总之，多线程和信号之间的冲突是可能的，但可以通过正确的编程实践来避免。



## 面试项目总结

目前问的最多的是集群聊天服务器，但是这个项目貌似做的人也很多啊。

不管别人，关键是从面试里面知道自己应该做哪些工作：

* 自己的思考+工作量
* 自己为项目做了什么，压测？新功能？

目前业务方面是没有必要再去增加了，就是需要做一下压测。
