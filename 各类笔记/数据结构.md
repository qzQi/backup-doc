



BST

二叉搜索树，



BBST：balanceed bst



AVL：       

左右高度差不大于1的bst



rbtree



### KMP

![image-20220403223403802](image/image-20220403223403802.png)



![image-20220403221447397](image/image-20220403221447397.png)





整个前缀无需比对？这里虽然还是仅仅走了一步，但是不需要重复比对。

![](image/image-20220403221849828.png)



一次走好几步！！！不必一步一步了





![image-20220403222320325](image/image-20220403222320325.png)







什么时候j<0？当x表示的字符不存在pattern的时候？**就是与text里面的i匹配的时候，再pattern里面找不到相应的信息** 

![image-20220403223751079](image/image-20220403223751079.png)







一个实例

![image-20220403225440402](image/image-20220403225440402.png)







失配的位置，理解next表！！！失配位置处的前缀与后缀必须有对称



在点j所有的候选情况里面选取的是使pattern位移最小的，也就是说**选取最多的前缀与后缀匹配**。



![image-20220405191912769](image/image-20220405191912769.png)





理解-1

![image-20220405192534656](image/image-20220405192534656.png)





![image-20220405192711875](image/image-20220405192711875.png)



next[i]的语义表面，在pattern的i的前面存在一个长度为next[i]的真前缀与真后缀重合。这个匹配缀取最大值